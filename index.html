<!DOCTYPE html>
<html>
  <head>
    <title>Проект "Комменты"</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="styles_2.11.css" />
  </head>

  <body>
    <div class="container">
      <ul class="comments">

         <!-- рендерится из JS -->

      </ul>

      <div class="delete-form">
        <button class="delete-form-button">Удалить последний комментарий</button>
      </div>


      <div class="add-form">
        <input
          type="text"
          class="add-form-name"
          placeholder="Введите ваше имя"
        />
        <textarea
          type="textarea"
          class="add-form-text"
          placeholder="Введите ваш коментарий"
          rows="4"
        ></textarea>
        <div class="add-form-row">
          <button class="add-form-button">Написать</button>
        </div>
      </div>
    </div>
  </body>




  <script>
    "use strict";


  const ulElement = document.querySelector('ul[class="comments"]');
  const buttonElement = document.querySelector('button[class="add-form-button"]');
  const nameElement = document.querySelector('input[class="add-form-name"]');
  const textElement = document.querySelector('textarea[class="add-form-text"]');




  // СТРУКТУРА ХРАНЕНИЯ ДАННЫХ - МАССИВ ОБЪЕКТОВ

  const comments = [
    {
      nameAuthor: "Глеб Фокин",
      timeComment: "12.02.22 12:18",
      commentText: "Это будет первый комментарий на этой странице",
      likesCounter: 3,
      isLike: false,
      isEdit: false,
    },
    {
      nameAuthor: "Варвара Н.",
      timeComment: "13.02.22 19:22",
      commentText: "Мне нравится как оформлена эта страница! ❤",
      likesCounter: 75,
      isLike: true,
      isEdit: false,
    },
  ];





  // ЛАЙК КОММЕНТАРИЯ                  

  const initLikeComments = () => {       // объявление функции добавления/удаления лайка(нажатие на сердечко)
    const listLikeButtons = document.querySelectorAll('.like-button');
    
    for (let like of listLikeButtons) {
      like.addEventListener("click", () => {
        let indexLike = like.dataset.index;
        if (comments[indexLike].isLike) {
          comments[indexLike].likesCounter -= 1;
          comments[indexLike].isLike = false;
        } else {
          comments[indexLike].likesCounter += 1;
          comments[indexLike].isLike = true;
        }

        renderComments();

      })
    }
  };




  
    // РЕПЛАЙ НА КОММЕНТАРИЙ

      const initEditComment = () => {         // объявление функции ответа на комментарий с цитированием автора и текста

        const listTextComments = document.querySelectorAll('.comment-text');

        for (let TextComment of listTextComments) {
            TextComment.addEventListener("click", (event) => {
            let indexText = TextComment.dataset.index;
            let editComment = `QUOTE_BEGIN ${comments[indexText].nameAuthor}:\n${comments[indexText].commentText} QUOTE_END \n`;
            textElement.value = editComment;

            renderComments();

          })
        }
      }







    // РЕНДЕРИНГ СТРАНИЦЫ

    const renderComments = () => {         // объявление функции рендеринга

        const commentsHTML = comments.map((comment, ind) => {
        const Liked = `
        <li class="comment">
            <div class="comment-header">
                <div>${comment.nameAuthor}</div>
                <div>${comment.timeComment}</div>
            </div>
            <div class="comment-body">
                <div data-index="${ind}" class="comment-text">
                ${comment.commentText.replaceAll("QUOTE_BEGIN", "<div class='quote'>").replaceAll("QUOTE_END", "</div>")}
                </div>
            </div>
            <div class="comment-footer">
                <div class="likes">
                <span class="likes-counter">${comment.likesCounter}</span>
                <button data-index="${ind}" class="like-button ${comment.isLike ? "-active-like": ""}"></button>
                </div>
            </div>
            </li> `;
        return Liked;
        }).join("")
        ulElement.innerHTML = commentsHTML;

        initLikeComments();           // вызов функции добавления/удаления лайка(нажатие на сердечко)

        initEditComment();            // вызов функции ответа на комментарий с цитированием автора и текста

    }
    renderComments();                // вызов функции рендеринга







  // ПЕРЕКРАСКА КНОПКИ "НАПИСАТЬ" В ФОРМЕ ВВОДА КОММЕНТАРИЯ ПОСЛЕ НАЧАЛА ВВОДА В ПОЛЕ ИМЕНИ И ТЕКСТА

  buttonElement.className = 'error-add-form-button'; // сбрасываю стиль кнопки "Написать" на серый, чтобы было понятно,
  // что без заполнения полей Имя и Комментарий отправить форму нельзя

  let nameElementCheck = false;          // для проверки событий пользователь начинает печать и в поле Имя,
  let textElementCheck = false;          // и в поле Комментарий ввожу булевые переменные

  function handleInputs() {              // объявление функции, которая перекрашивает кнопку "Написать" в зеленый цвет
    if (nameElementCheck && textElementCheck) {      // ввод и в Имя и в текст произошел
      buttonElement.className = 'add-form-button';   // перекрашиваем кнопку
    }
  }

  nameElement.addEventListener("input", () => {   // вызов функции перекраски "Написать" в зеленый цвет
    nameElementCheck = true;
    handleInputs();
  });

  textElement.addEventListener("input", () => {   // вызов функции перекраски "Написать" в зеленый цвет
    textElementCheck = true;
    handleInputs();
  });






  // ДОБАВЛЕНИЕ НОВОГО КОММЕНТАРИЙ ЧЕРЕЗ ФОРМУ ВВОДА

  let buttonCheck = false;  // для проверки событий нажата либо кнопка "Написать",
  let enterCheck = false;   // либо кнопка "Enter" ввожу переменные, со значением по умолчанию

  function handleButtons() {          // объявление функции добавления комментария

    let currentTime = new Date();
    let commentTime = `${currentTime.toLocaleDateString('ru-Ru', { day: "2-digit", month: "2-digit", year: "2-digit" })} ${currentTime.toLocaleTimeString('ru-Ru', { hour: "2-digit", minute: "2-digit" })}`;

    if (buttonCheck || enterCheck) {  // клик либо на кнопку "Написать", либо на "Enter" произошел
      if (nameElement.value === '' || textElement.value === '') { // если имя или текст незаполнены, но кнопка "Написать" или "Enter" нажата,
        buttonElement.className = 'error-add-form-button';        // то элемент не добавлять и кнопку "Написать" покрасить в серый цвет
        return;
      }
      comments.push({                   // добавление коммента на страницу путем включения объекта в массив
        nameAuthor: nameElement.value
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;"),
        timeComment: commentTime,
        commentText: textElement.value
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;"),
        likesCounter: 0,
        isLike: false,
        isEdit: false,
      });
      
      renderComments();                 // перерисовываем страницу с учетом нового объекта в массиве
      
      nameElement.value = '';           // возвращаем начальные значения полям формы ввода
      textElement.value = '';
      buttonElement.className = 'error-add-form-button';
      nameElementCheck = false;
      textElementCheck = false;
    }
  }

  buttonElement.addEventListener("click", () => {   // вызов функции добавления комментария по клику на кнопку "Написать"
    buttonCheck = true;
    handleButtons();                     
  });

  document.addEventListener("keyup", (event) => {   // вызов функции добавления комментария по клику на кнопку "Enter"
    if (event.key === 'Enter') {
      enterCheck = true;
      handleButtons();                   
    }
  });









  // функционал удаления последнего комментария
  let buttonDelete = document.querySelector('button[class="delete-form-button"]');
  buttonDelete.addEventListener("click", () => {
    let lis = document.querySelectorAll('.comment');  // создаем коллекцию/псевдомассив из элементов с классом '.comment'
    let liDelete = lis[lis.length - 1];  // определяем элемент для удаления по индексу последнего в коллекции
    liDelete.parentNode.removeChild(liDelete); // вызываем метод удаления потомка коллекции - элемента для удаления
    });




  </script>
</html>
